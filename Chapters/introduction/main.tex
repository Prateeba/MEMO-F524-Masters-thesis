\chapter{Introduction}
\label{ch:intro}
%Algorithmic graph theory is useful in modeling real-world problems, where the domain of the problem is modeled as a graph and the constraints on the solution
%define feasible solutions. For example, consider the problem of activating a number of routers subject to pairwise incompatibility constraints. Here, router
%compatibilities can be modeled as a graph and a feasible solution as an independent set. Traditionally, the real-world user
%first defines a problem instance and then uses an algorithm to find a feasible solution which she then ‘‘implements’’ in the
%real world. However, some real-world situations do not follow this simple paradigm and are more dynamic because they
%allow the solution to ‘‘evolve’’ over time. For example, consider the situation where a set of routers is already active but
%the operator has been instructed to use a different set of routers, which also form an independent set. To maintain network
%functionality, she can only switch one router at a time, but she has to make sure that there are always enough active routers
%(say, at least k) and that they are pairwise compatible. Thus, she would like to switch between the two configurations, while
%maintaining enough compatible routers at every intermediate step.
%In general, this type of situation gives rise to a reconfiguration framework

Reconfiguration problems are combinatorial problems in which we are given a collection of configurations, together with some
transformation rule(s) that allows us to change one configuration to another such that each intermediate solution remains satisfiable at all times.
A configuration can be the arrangement of puzzle pieces, the location of a robot with respect to obstacles in space, or the ordering of symbols to
form a string. Combinatorial reconfiguration problems ask the reachability between the two given satisfying solutions. The area of reconfiguration
considers both structural and algorithmic problems on the space of solutions, under various definitions of feasibility and adjacency.


The \textit{reconfiguration framework} is defined in terms of a source problem, an instance of the source problem, a definition of a feasible solution
and a definition of adjacency of feasible solutions. Viewing reconfiguration problems from a graph-theoretic perspective, the notion of a
\textit{reconfiguration graph} naturally arises. Let $G$ be a reconfiguration graph where the vertex set consists of all
possible configurations and two nodes are connected by an edge if the corresponding configurations can each be obtained from the other by the
application of a single transformation rule,\textit{a reconfiguration step}. Any path or walk in the reconfiguration graph corresponds to a
sequence of reconfiguration steps called a \textit{reconfiguration sequence}.

Interest in combinatorial reconfiguration begun with the Sliding blocks puzzles and steadily increased during the last decade. The reconfiguration framework has recently been applied in a number of settings,
including vertex coloring \cite{bonsma}, \cite{bonsma_cereceda}, \cite{cereceda}, list-edge coloring \cite{ito_reconfiguration_2009}, clique, set cover,
integer programming, matching, spanning tree, matroid bases \cite{DBLP:journals/tcs/ItoDHPSUU11}, block puzzles \cite{hearn_pspace-completeness_2004},
shortest path \cite{shortest_path}, independent set \cite{hearn_pspace-completeness_2004},\cite{DBLP:journals/tcs/ItoDHPSUU11}, \cite{kaminski_complexity_2012},
and satisfiability \cite{DBLP:journals/siamcomp/GopalanKMP09}.
Many problems in $\P$ have their reconfigurability problems in $\P$ as well, such as spanning tree, matching, and matroid problems in general. On the other hand,
the reconfigurability of independent set, set cover, and integer programming are $\PSPACE$-complete \cite{DBLP:journals/tcs/ItoDHPSUU11}. In general however, knowing
the complexity of a decision problem does not allow us to directly infer the complexity status of its reconfigurability problem(s). Several $\NP$-complete problems have
reconfigurability analogues that are in $\P$, for example the $3$-colorability problem \cite{DBLP:conf/iwoca/JohnsonCH08}. Alternatively, some problems in $\P$
have reconfigurability versions that are $\PSPACE$-complete, such as shortest paths \cite{DBLP:journals/corr/abs-1009-3217} or the problem of deciding whether
two $4$-colorings of a given bipartite or planar graph are reconfigurable \cite{bonsma}.


This thesis does not attempt to catalogue all research results that can be categorized as reconfiguration, but instead focuses on demonstrating the
main themes in the area (Satisfiability reconfiguration problems and Binary integer programming reconfiguration problems) and complement some
recent $\PSPACE-$hardness proof given in \cite{cardinal_reconfiguration_2018}. More precisely, we go over and detail the $\PSPACE-$completeness of
the following decision problems :
\begin{itemize}
    \item Given two subsets of a set $S$ of integers of integers with the same sum, can one subset be transformed into the other by adding or removing
    at most 3 elements of $S$ at a time, such that the intermediate subsets also have the same sum ?
    \item Given two points in $\{0,1\}^{n}$ contained in a polytope $P$ specified by a constant number of linear inequalities, is there a path in the
    $n-$hypercube connecting the two points and contained in $P$ ?
\end{itemize}

In the first half of this thesis, we study the Nondeterministic Constraint Logic of Computation introduced by Hearn and Demaine.
The NCL framework consists of different graph games ($i.e.$ problems) specific for every major complexity class, more specifically the class $\PSPACE$.
These graph games are created in order to facilitate the reduction to other games. Reviewing NCL as part of this thesis is fundamental since it has
been and still is the trigger for many $\PSPACE-$ hardness results in recreational mathematics.

The the second part of this thesis focuses on Satisfiability reconfiguration problems and Binary integer programming reconfiguration problems.
Finally, in Chapter 7 our conclusions are presented and some proposals for future work are made.


