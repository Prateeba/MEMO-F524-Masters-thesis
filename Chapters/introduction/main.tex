\chapter{Introduction}\label{ch:intro}
Reconfiguration problems are computational problems in which we wish to find a step-by-step transformation between two feasible solutions
of a problem such that all intermediate results are also feasible. A solution can be the arrangement of puzzle
pieces, the ordering of symbols to form a string or the location of a robot with respect to obstacles in space. Computational reconfiguration
problems ask the reachability between the two given satisfying solutions. The area of reconfiguration considers both structural and algorithmic
problems on the space of solutions, under various definitions of feasibility and adjacency.


The \textit{reconfiguration framework} is defined in terms of a source problem, an instance of the source problem, a definition of a feasible solution
and a definition of adjacency of feasible solutions. Viewing reconfiguration problems from a graph-theoretic perspective, the notion of a
\textit{reconfiguration graph} naturally arises. Let $G$ be a reconfiguration graph where the vertex set consists of all
possible configurations and two nodes are connected by an edge if the corresponding configurations can each be obtained from the other by the
application of a single transformation rule, \textit{a reconfiguration step}. Any path or walk in the reconfiguration graph corresponds to a
sequence of reconfiguration steps called a \textit{reconfiguration sequence}.

Interest in computational reconfiguration begun with the Sliding blocks puzzles and steadily increased during the last decade. The reconfiguration framework has recently been applied in a number of settings,
including vertex colouring \cite{bonsma, bonsma_cereceda, cereceda}, list-edge colouring \cite{ito_reconfiguration_2009}, clique, set cover,
integer programming, matching, spanning tree, matroid bases \cite{DBLP:journals/tcs/ItoDHPSUU11}, block puzzles \cite{hearn_pspace-completeness_2004},
shortest path \cite{shortest_path}, independent set \cite{hearn_pspace-completeness_2004, DBLP:journals/tcs/ItoDHPSUU11, kaminski_complexity_2012},
and satisfiability \cite{DBLP:journals/siamcomp/GopalanKMP09}.
Many problems in $\P$ have their reconfiguration problems in $\P$ as well, such as spanning tree, matching, and matroid problems in general. On the other hand,
the reconfigurability of independent set, set cover, and integer programming are $\PSPACE$-complete \cite{DBLP:journals/tcs/ItoDHPSUU11}. In general however, knowing
the complexity of a decision problem does not allow us to directly infer the complexity status of its reconfiguration problem(s). Several $\NP$-complete problems have
their reconfiguration analogues that are in $\P$, for example the $3$-colourability problem \cite{DBLP:conf/iwoca/JohnsonCH08}. Alternatively, some problems in $\P$
have their reconfiguration versions that are $\PSPACE$-complete, such as shortest paths \cite{DBLP:journals/corr/abs-1009-3217} or the problem of deciding whether
two $4$-colourings of a given bipartite or planar graph are reconfigurable \cite{bonsma}.

This thesis does not attempt to catalogue all research results that can be categorized as reconfiguration, but instead focuses on demonstrating the
main themes in the area and complement some recent $\PSPACE-$hardness proofs given in \cite{cardinal_reconfiguration_2018}. More precisely, we go
over and detail the $\PSPACE-$completeness of the following decision problems :
\begin{itemize}
    \item Given two subsets of a set $S$ of integers with the same sum, can one subset be transformed into the other by adding or removing
    at most 3 elements of $S$ at a time, such that the intermediate subsets also have the same sum ?
    \item Given two independent sets $I_b$ and $I_r$ of a graph $G = (V,E)$ and suppose that a labelled token is placed on each vertex in $I_b$ where
    each label is unique, is it possible to transform $I_b$ into $I_r$ such that all intermediate solutions are also independent sets ?
\end{itemize}

In the first half of this thesis, we study the Nondeterministic Constraint Logic of Computation introduced by Hearn and Demaine.
The NCL framework consists of different graph games ($i.e.$ problems) specific for every major complexity class, more specifically the
class $\PSPACE$. These graph games are created in order to facilitate the reduction to other games. Reviewing NCL as part of this thesis is
fundamental since it has been and still is the trigger for many $\PSPACE-$ hardness results.

The second part of this thesis focuses on Satisfiability reconfiguration problems and the Subset sum reconfiguration problem and
provides a geometric interpretation for the latter problem with the intent on helping to have a better understanding of the reconfiguration graph and its
connectivity properties. Finally, in chapter \ref{chap:conclu} our conclusions are presented and some proposals for future work are made.


