\chapter{Introduction}\label{ch:intro}
Reconfiguration problems are combinatorial problems in which we are given a collection of configurations, together with some
transformation rule(s) that allows us to change one configuration to another such that each intermediate solution remains satisfiable at all times.
A configuration can be the arrangement of puzzle pieces, the location of a robot with respect to obstacles in space, or the ordering of symbols to
form a string. Combinatorial reconfiguration problems ask the reachability between the two given satisfying solutions. The area of reconfiguration
considers both structural and algorithmic problems on the space of solutions, under various definitions of feasibility and adjacency.


The \textit{reconfiguration framework} is defined in terms of a source problem, an instance of the source problem, a definition of a feasible solution
and a definition of adjacency of feasible solutions. Viewing reconfiguration problems from a graph-theoretic perspective, the notion of a
\textit{reconfiguration graph} naturally arises. Let $G$ be a reconfiguration graph where the vertex set consists of all
possible configurations and two nodes are connected by an edge if the corresponding configurations can each be obtained from the other by the
application of a single transformation rule,\textit{a reconfiguration step}. Any path or walk in the reconfiguration graph corresponds to a
sequence of reconfiguration steps called a \textit{reconfiguration sequence}.

Interest in combinatorial reconfiguration begun with the Sliding blocks puzzles and steadily increased during the last decade. The reconfiguration framework has recently been applied in a number of settings,
including vertex coloring \cite{bonsma}, \cite{bonsma_cereceda}, \cite{cereceda}, list-edge coloring \cite{ito_reconfiguration_2009}, clique, set cover,
integer programming, matching, spanning tree, matroid bases \cite{DBLP:journals/tcs/ItoDHPSUU11}, block puzzles \cite{hearn_pspace-completeness_2004},
shortest path \cite{shortest_path}, independent set \cite{hearn_pspace-completeness_2004},\cite{DBLP:journals/tcs/ItoDHPSUU11}, \cite{kaminski_complexity_2012},
and satisfiability \cite{DBLP:journals/siamcomp/GopalanKMP09}.
Many problems in $\P$ have their reconfigurability problems in $\P$ as well, such as spanning tree, matching, and matroid problems in general. On the other hand,
the reconfigurability of independent set, set cover, and integer programming are $\PSPACE$-complete \cite{DBLP:journals/tcs/ItoDHPSUU11}. In general however, knowing
the complexity of a decision problem does not allow us to directly infer the complexity status of its reconfigurability problem(s). Several $\NP$-complete problems have
reconfigurability analogues that are in $\P$, for example the $3$-colorability problem \cite{DBLP:conf/iwoca/JohnsonCH08}. Alternatively, some problems in $\P$
have reconfigurability versions that are $\PSPACE$-complete, such as shortest paths \cite{DBLP:journals/corr/abs-1009-3217} or the problem of deciding whether
two $4$-colorings of a given bipartite or planar graph are reconfigurable \cite{bonsma}.

This thesis does not attempt to catalogue all research results that can be categorized as reconfiguration, but instead focuses on demonstrating the
main themes in the area and complement some recent $\PSPACE-$hardness proofs given in \cite{cardinal_reconfiguration_2018}. More precisely, we go
over and detail the $\PSPACE-$completeness of the following decision problems :
\begin{itemize}
    \item Given two subsets of a set $S$ of integers of integers with the same sum, can one subset be transformed into the other by adding or removing
    at most 3 elements of $S$ at a time, such that the intermediate subsets also have the same sum ?
    \item In the process of complementing the $3$-move subset sum reconfiguration problem, we also give a simple hardness proof the labelled variant
    of the sliding token problem, described in section \ref{sec:labeled_sliding_token}.
\end{itemize}

In the first half of this thesis, we study the Nondeterministic Constraint Logic of Computation introduced by Hearn and Demaine.
The NCL framework consists of different graph games ($i.e.$ problems) specific for every major complexity class, more specifically the
class $\PSPACE$. These graph games are created in order to facilitate the reduction to other games. Reviewing NCL as part of this thesis is
fundamental since it has been and still is the trigger for many $\PSPACE-$ hardness results in recreational mathematics.

The second part of this thesis focuses on Satisfiability reconfiguration problems and the Subset sum reconfiguration problem and
provides a visual support for the latter problem with the intent on helping on having a better idea of the reconfiguration graph and it's
connectivity properties. Finally, in Chapter 7 our conclusions are presented and some proposals for future work are made.


